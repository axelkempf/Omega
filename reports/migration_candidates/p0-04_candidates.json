{
  "meta": {
    "generated_by": "tools/migration_candidates.py",
    "scope": "P0-04",
    "baselines_dir": "reports/performance_baselines",
    "src_root": "src"
  },
  "candidates": [
    {
      "key": "indicator_cache",
      "name": "Indicator Cache",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/indicator_cache.py"
      ],
      "src_files": [
        "src/backtest_engine/core/indicator_cache.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_indicator_cache.json",
      "impact_seconds": 1.141822,
      "perf_bucket": "High",
      "function_coverage": 100.0,
      "parameter_coverage": 100.0,
      "type_bucket": "High",
      "recommended_priority": "High",
      "notes": "Hot-path für Indikatoren + Cache; starker Kandidat für Rust (ndarray/Arrow)."
    },
    {
      "key": "multi_symbol_slice",
      "name": "Multi-Symbol Slice",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/multi_symbol_slice.py"
      ],
      "src_files": [
        "src/backtest_engine/core/multi_symbol_slice.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_multi_symbol_slice.json",
      "impact_seconds": 7.235017,
      "perf_bucket": "High",
      "function_coverage": 22.2,
      "parameter_coverage": 90.0,
      "type_bucket": "Low",
      "recommended_priority": "Medium",
      "notes": "Auffällig teuer in Baseline; Kandidat für Rust (Vectorisierung/Zero-copy)."
    },
    {
      "key": "symbol_data_slicer",
      "name": "Symbol Data Slicer",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/symbol_data_slicer.py"
      ],
      "src_files": [
        "src/backtest_engine/core/symbol_data_slicer.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_symbol_data_slicer.json",
      "impact_seconds": 0.731318,
      "perf_bucket": "Medium",
      "function_coverage": 81.8,
      "parameter_coverage": 100.0,
      "type_bucket": "High",
      "recommended_priority": "Medium",
      "notes": "Hohe Call-Frequenz im Core-Loop; Rust kann Branching/Indexing beschleunigen."
    },
    {
      "key": "optimizer",
      "name": "Optimizer (Final Selection / Robust Zone)",
      "target": "Julia",
      "src_globs": [
        "backtest_engine/optimizer"
      ],
      "src_files": [
        "src/backtest_engine/optimizer/__init__.py",
        "src/backtest_engine/optimizer/_settings.py",
        "src/backtest_engine/optimizer/final_param_selector.py",
        "src/backtest_engine/optimizer/grid_searcher.py",
        "src/backtest_engine/optimizer/instrumentation.py",
        "src/backtest_engine/optimizer/optuna_optimizer.py",
        "src/backtest_engine/optimizer/robust_zone_analyzer.py",
        "src/backtest_engine/optimizer/symbol_grid.py",
        "src/backtest_engine/optimizer/walkforward.py",
        "src/backtest_engine/optimizer/walkforward_plot.py",
        "src/backtest_engine/optimizer/walkforward_utils.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_optimizer.json",
      "impact_seconds": 0.797464,
      "perf_bucket": "Medium",
      "function_coverage": 78.8,
      "parameter_coverage": 93.2,
      "type_bucket": "Medium",
      "recommended_priority": "Medium",
      "notes": "Explorativ/Research-lastig; Julia kann Iteration beschleunigen (aber FFI/Arrow klären)."
    },
    {
      "key": "portfolio",
      "name": "Portfolio",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/portfolio.py"
      ],
      "src_files": [
        "src/backtest_engine/core/portfolio.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_portfolio.json",
      "impact_seconds": 0.248001,
      "perf_bucket": "Medium",
      "function_coverage": 57.1,
      "parameter_coverage": 100.0,
      "type_bucket": "Medium",
      "recommended_priority": "Medium",
      "notes": "Stateful Hot-path; Ownership/Mutability muss sauber spezifiziert werden."
    },
    {
      "key": "slippage_and_fee",
      "name": "Slippage & Fee",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/slippage_and_fee.py"
      ],
      "src_files": [
        "src/backtest_engine/core/slippage_and_fee.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_slippage_and_fee.json",
      "impact_seconds": 0.736007,
      "perf_bucket": "Medium",
      "function_coverage": 50.0,
      "parameter_coverage": 100.0,
      "type_bucket": "Medium",
      "recommended_priority": "Medium",
      "notes": "Reine Mathematik; sehr gut als frühes, kleines Rust-Pilot-Modul."
    },
    {
      "key": "event_engine",
      "name": "Event Engine",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/event_engine.py"
      ],
      "src_files": [
        "src/backtest_engine/core/event_engine.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_event_engine.json",
      "impact_seconds": 0.336732,
      "perf_bucket": "Medium",
      "function_coverage": 0.0,
      "parameter_coverage": 100.0,
      "type_bucket": "Low",
      "recommended_priority": "Low",
      "notes": "Core-Loop; sehr sensibel – Migration erst nach Interface-Spec + Tests."
    },
    {
      "key": "execution_simulator",
      "name": "Execution Simulator",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/core/execution_simulator.py"
      ],
      "src_files": [
        "src/backtest_engine/core/execution_simulator.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_execution_simulator.json",
      "impact_seconds": 0.173885,
      "perf_bucket": "Medium",
      "function_coverage": 22.2,
      "parameter_coverage": 95.7,
      "type_bucket": "Low",
      "recommended_priority": "Low",
      "notes": "Trade-Matching + Exits; gute Rust-Kandidatur nach klarer I/O-Spec."
    },
    {
      "key": "rating",
      "name": "Rating Modules",
      "target": "Rust",
      "src_globs": [
        "backtest_engine/rating"
      ],
      "src_files": [
        "src/backtest_engine/rating/__init__.py",
        "src/backtest_engine/rating/cost_shock_score.py",
        "src/backtest_engine/rating/data_jitter_score.py",
        "src/backtest_engine/rating/p_values.py",
        "src/backtest_engine/rating/robustness_score_1.py",
        "src/backtest_engine/rating/stability_score.py",
        "src/backtest_engine/rating/strategy_rating.py",
        "src/backtest_engine/rating/stress_penalty.py",
        "src/backtest_engine/rating/timing_jitter_score.py",
        "src/backtest_engine/rating/tp_sl_stress_score.py",
        "src/backtest_engine/rating/trade_dropout_score.py",
        "src/backtest_engine/rating/ulcer_index_score.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_rating.json",
      "impact_seconds": 0.077729,
      "perf_bucket": "Low",
      "function_coverage": 100.0,
      "parameter_coverage": 100.0,
      "type_bucket": "High",
      "recommended_priority": "Low",
      "notes": "Viele numerische Scores; geeignet für Rust, aber erst Schema/Output-CSV beachten."
    },
    {
      "key": "walkforward",
      "name": "Walkforward (stubbed window)",
      "target": "Julia",
      "src_globs": [
        "backtest_engine/optimizer/walkforward.py"
      ],
      "src_files": [
        "src/backtest_engine/optimizer/walkforward.py"
      ],
      "baseline": "reports/performance_baselines/p0-01_walkforward_stub.json",
      "impact_seconds": 0.132846,
      "perf_bucket": "Low",
      "function_coverage": 66.7,
      "parameter_coverage": 100.0,
      "type_bucket": "Medium",
      "recommended_priority": "Low",
      "notes": "Orchestrierung; primär I/O + Pipeline – eher später, nach Stabilisierung."
    },
    {
      "key": "analysis_pipelines",
      "name": "Analysis Pipelines",
      "target": "Julia",
      "src_globs": [
        "backtest_engine/analysis"
      ],
      "src_files": [
        "src/backtest_engine/analysis/__init__.py",
        "src/backtest_engine/analysis/backfill_walkforward_equity_curves.py",
        "src/backtest_engine/analysis/combine_equity_curves.py",
        "src/backtest_engine/analysis/combined_walkforward_matrix_analyzer.py",
        "src/backtest_engine/analysis/final_combo_equity_plotter.py",
        "src/backtest_engine/analysis/metric_adjustments.py",
        "src/backtest_engine/analysis/walkforward_analyzer.py"
      ],
      "baseline": null,
      "impact_seconds": null,
      "perf_bucket": "Unknown",
      "function_coverage": 92.5,
      "parameter_coverage": 99.3,
      "type_bucket": "High",
      "recommended_priority": "Low",
      "notes": "Research/Plots; Julia lohnt sich, aber Performance-Impact schwerer zu messen (noch keine Baseline)."
    }
  ],
  "rules": {
    "perf_bucket": {
      "High": ">= 1.0s",
      "Medium": ">= 0.15s",
      "Low": "< 0.15s"
    },
    "type_bucket": {
      "High": "return>=80% AND params>=90%",
      "Medium": "return>=50% AND params>=80%",
      "Low": "else"
    },
    "recommended_priority": "Derived from perf_bucket + type_bucket (conservative)."
  }
}
